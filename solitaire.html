<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>Solitaire</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background: linear-gradient(
          135deg,
          #0d7a32 0%,
          #065420 50%,
          #043d17 100%
        );
        background-attachment: fixed;
        color: white;
        min-height: 100vh;
        padding: 20px;
        user-select: none;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
      }
      .game-header {
        text-align: center;
        margin-bottom: 20px;
      }
      .game-title {
        font-size: 28px;
        font-weight: 700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        margin-bottom: 15px;
        letter-spacing: 2px;
      }
      .top-section {
        display: flex;
        justify-content: space-between;
        margin-bottom: 25px;
        pointer-events: none;
      }
      .stock-waste {
        display: flex;
        gap: 15px;
        pointer-events: none;
      }
      .foundations {
        display: flex;
        gap: 15px;
        pointer-events: none;
      }
      .tableau {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        min-height: 400px;
        pointer-events: none;
      }
      .card-slot,
      .tableau-pile {
        pointer-events: auto;
      }
      .card-slot {
        width: 100px;
        height: 140px;
        padding: 2px;
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        position: relative;
        background: rgba(0, 0, 0, 0.15);
        transition: all 0.2s ease;
      }
      .card-slot .card {
        top: 3px;
        left: 3px;
        transform: none;
      }
      .card-slot .card:hover {
        transform: translateY(-8px);
      }
      .card-slot:hover {
        border-color: rgba(255, 255, 255, 0.5);
        background: rgba(0, 0, 0, 0.2);
      }
      .card-slot::after {
        content: attr(data-placeholder);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 28px;
        color: rgba(255, 255, 255, 0.25);
        font-weight: 300;
      }
      .card-slot:has(.card)::after {
        display: none;
      }
      #stock {
        cursor: pointer;
      }
      #stock::after {
        content: "â™ ";
        font-size: 32px;
      }
      #stock:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .foundation-slot::after {
        font-size: 36px;
      }
      #foundation-0::after {
        content: "â™ ";
        color: rgba(255, 255, 255, 0.2);
      }
      #foundation-1::after {
        content: "â™¥";
        color: rgba(220, 80, 80, 0.3);
      }
      #foundation-2::after {
        content: "â™¦";
        color: rgba(220, 80, 80, 0.3);
      }
      #foundation-3::after {
        content: "â™£";
        color: rgba(255, 255, 255, 0.2);
      }
      .card {
        width: 94px;
        height: 132px;
        background: linear-gradient(145deg, #ffffff 0%, #f8f8f8 100%);
        border-radius: 10px;
        position: absolute;
        cursor: grab;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 6px 8px;
        color: black;
        font-weight: 600;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        border: 1px solid rgba(0, 0, 0, 0.08);
        overflow: hidden;
      }
      .card:active {
        cursor: grabbing;
      }
      .card.back {
        background: linear-gradient(
          135deg,
          #1a5a8a 0%,
          #1e6ca0 25%,
          #1a5a8a 25%,
          #1a5a8a 50%,
          #1e6ca0 50%,
          #1e6ca0 75%,
          #1a5a8a 75%,
          #1a5a8a 100%
        );
        background-size: 16px 16px;
        color: transparent;
        border: 3px solid #0d3d5c;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.15),
          inset 0 0 20px rgba(0, 0, 0, 0.1);
      }
      .card.back::before {
        content: "";
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        bottom: 8px;
        border: 2px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
      }
      .card:hover {
        transform: translateY(-8px);
        z-index: 1000 !important;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2),
          0 12px 24px rgba(0, 0, 0, 0.15);
      }
      .card.dragging {
        opacity: 0.9;
        z-index: 1000 !important;
        transform: scale(1.02);
      }
      .card.back:hover {
        transform: none;
        z-index: auto !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.15);
      }
      .card-red {
        color: #c41e3a;
      }
      .card-black {
        color: #1a1a1a;
      }
      .card-value {
        font-size: 18px;
        line-height: 1;
        font-weight: 700;
      }
      .card-suit {
        font-size: 14px;
        line-height: 1;
        margin-top: 1px;
      }
      .card-center {
        font-size: 28px;
        align-self: center;
        opacity: 0.9;
        margin: -4px 0;
      }
      .tableau-pile {
        position: relative;
        width: 100px;
        min-height: 140px;
        border-radius: 12px;
        transition: background 0.2s ease;
      }
      .tableau-pile:empty {
        border: 2px dashed rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.1);
      }
      .tableau-pile .card {
        position: absolute;
      }
      .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding: 15px 20px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 16px;
        backdrop-filter: blur(10px);
        pointer-events: auto;
      }
      .button-group {
        display: flex;
        gap: 10px;
      }
      button {
        padding: 10px 20px;
        background: linear-gradient(145deg, #ffffff 0%, #e8e8e8 100%);
        border: none;
        border-radius: 10px;
        color: #065420;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        font-family: inherit;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
      }
      button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
      }
      button:disabled {
        background: #a0a0a0;
        color: #2a2a2a;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .stats {
        display: flex;
        gap: 20px;
        align-items: center;
      }
      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        min-width: 80px;
      }
      .stat-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.7;
        margin-bottom: 4px;
      }
      .stat-value {
        font-size: 20px;
        font-weight: 700;
      }
      .win-message {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(8px);
      }
      .win-content {
        text-align: center;
        animation: winPopup 0.5s ease-out;
      }
      @keyframes winPopup {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .win-title {
        font-size: 48px;
        font-weight: 700;
        margin-bottom: 10px;
        background: linear-gradient(135deg, #ffd700, #ffec8b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: none;
      }
      .win-subtitle {
        font-size: 24px;
        opacity: 0.9;
        margin-bottom: 30px;
      }
      .win-stats {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin-bottom: 30px;
      }
      .win-stat {
        text-align: center;
      }
      .win-stat-value {
        font-size: 32px;
        font-weight: 700;
        color: #ffd700;
      }
      .win-stat-label {
        font-size: 14px;
        opacity: 0.7;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .win-button {
        padding: 15px 40px;
        font-size: 18px;
        background: linear-gradient(135deg, #ffd700, #f0c000);
        color: #1a1a1a;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 700;
        transition: all 0.2s ease;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
      }
      .win-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
      }
      @keyframes cardFlip {
        0% {
          transform: rotateY(0deg);
        }
        50% {
          transform: rotateY(90deg);
        }
        100% {
          transform: rotateY(0deg);
        }
      }
      .card.flipping {
        animation: cardFlip 0.3s ease-in-out;
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
          font-size: 14px;
        }
        .container {
          max-width: 100%;
        }
        .game-title {
          font-size: 20px;
          margin-bottom: 10px;
        }
        .card-slot {
          width: 42px;
          height: 60px;
          border-radius: 6px;
        }
        .card-slot .card {
          top: 2px;
          left: 2px;
        }
        .card-slot::after {
          font-size: 16px;
        }
        #stock::after {
          font-size: 18px;
        }
        .foundation-slot::after {
          font-size: 20px;
        }
        .card {
          width: 38px;
          height: 56px;
          padding: 2px;
          border-radius: 5px;
          overflow: hidden;
        }
        .card-value {
          font-size: 9px;
        }
        .card-suit {
          font-size: 8px;
          margin-top: 0;
        }
        .card-center {
          font-size: 12px;
        }
        .tableau {
          gap: 4px;
          min-height: 280px;
        }
        .tableau-pile {
          width: 42px;
          min-height: 60px;
        }
        .tableau-pile .card {
          top: 14px;
        }
        .controls {
          flex-direction: column;
          gap: 12px;
          padding: 12px 15px;
        }
        .stats {
          gap: 8px;
          flex-wrap: wrap;
          justify-content: center;
        }
        .stat-item {
          padding: 6px 10px;
          min-width: 65px;
        }
        .stat-label {
          font-size: 9px;
        }
        .stat-value {
          font-size: 16px;
        }
        button {
          padding: 8px 14px;
          font-size: 12px;
        }
        .stock-waste,
        .foundations {
          gap: 8px;
        }
        .top-section {
          margin-bottom: 15px;
        }
        .win-title {
          font-size: 32px;
        }
        .win-subtitle {
          font-size: 18px;
        }
        .win-stats {
          gap: 20px;
        }
        .win-stat-value {
          font-size: 24px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="controls">
        <div class="button-group">
          <button id="new-game">âœ¨ New Game</button>
          <button id="undo">â†© Undo</button>
        </div>
        <div class="stats">
          <div class="stat-item">
            <span class="stat-label">Moves</span>
            <span class="stat-value moves">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Time</span>
            <span class="stat-value time">0:00</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Score</span>
            <span class="stat-value score">0</span>
          </div>
        </div>
      </div>
      <div class="top-section">
        <div class="stock-waste">
          <div class="card-slot" id="stock"></div>
          <div class="card-slot" id="waste"></div>
        </div>
        <div class="foundations">
          <div class="card-slot foundation-slot" id="foundation-0"></div>
          <div class="card-slot foundation-slot" id="foundation-1"></div>
          <div class="card-slot foundation-slot" id="foundation-2"></div>
          <div class="card-slot foundation-slot" id="foundation-3"></div>
        </div>
      </div>
      <div class="tableau">
        <div class="tableau-pile" id="tableau-0"></div>
        <div class="tableau-pile" id="tableau-1"></div>
        <div class="tableau-pile" id="tableau-2"></div>
        <div class="tableau-pile" id="tableau-3"></div>
        <div class="tableau-pile" id="tableau-4"></div>
        <div class="tableau-pile" id="tableau-5"></div>
        <div class="tableau-pile" id="tableau-6"></div>
      </div>
    </div>
    <div class="win-message" id="win-message">
      <div class="win-content">
        <div class="win-title">ðŸŽ‰ You Won!</div>
        <div class="win-subtitle">Congratulations!</div>
        <div class="win-stats">
          <div class="win-stat">
            <div class="win-stat-value" id="win-moves">0</div>
            <div class="win-stat-label">Moves</div>
          </div>
          <div class="win-stat">
            <div class="win-stat-value" id="win-time">0:00</div>
            <div class="win-stat-label">Time</div>
          </div>
          <div class="win-stat">
            <div class="win-stat-value" id="win-score">0</div>
            <div class="win-stat-label">Score</div>
          </div>
        </div>
        <button class="win-button" id="play-again">Play Again</button>
      </div>
    </div>

    <script>
      // Game state
      let deck = [];
      let gameHistory = [];
      let gameWon = false;
      let stock = [];
      let waste = [];
      let foundations = [[], [], [], []];
      let tableau = [[], [], [], [], [], [], []];
      let moves = 0;
      let time = 0;
      let timer;
      let isDragging = false;
      let draggedCards = [];
      let draggedElement = null;
      let dragSourceElement = null;
      let startX, startY, initialX, initialY;
      let score = 0;

      // Card data
      const suits = ["â™ ", "â™¥", "â™¦", "â™£"];
      const values = [
        "A",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "J",
        "Q",
        "K",
      ];
      const colors = {
        "â™ ": "black",
        "â™¥": "red",
        "â™¦": "red",
        "â™£": "black",
      };

      // Initialize the game
      function initGame() {
        clearInterval(timer);
        timer = setInterval(updateTime, 1000);
        time = 0;
        moves = 0;
        score = 0;
        gameWon = false;
        gameHistory = [];
        updateStats();
        updateUndoButton();
        document.getElementById("win-message").style.display = "none";

        // Reset all piles
        stock = [];
        waste = [];
        foundations = [[], [], [], []];
        tableau = [[], [], [], [], [], [], []];

        // Create deck
        deck = [];
        for (let suit of suits) {
          for (let value of values) {
            deck.push({
              suit,
              value,
              color: colors[suit],
              faceUp: false,
            });
          }
        }

        // Shuffle deck
        shuffle(deck);

        // Deal cards to tableau
        for (let i = 0; i < 7; i++) {
          for (let j = 0; j <= i; j++) {
            const card = deck.pop();
            // Only the top card is face up
            if (j === i) {
              card.faceUp = true;
            }
            tableau[i].push(card);
          }
        }

        // Remaining cards go to stock
        stock = deck.slice();

        // Render the game
        renderGame();
      }

      // Shuffle an array (Fisher-Yates algorithm)
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // Render the game state
      function renderGame() {
        // Clear existing cards
        document.querySelectorAll(".card").forEach((card) => card.remove());

        // Set placeholder visibility for tableau piles
        for (let i = 0; i < 7; i++) {
          const tableauElement = document.getElementById(`tableau-${i}`);
          tableauElement.dataset.placeholder =
            tableau[i].length === 0 ? "K" : "";
          tableauElement.classList.add("card-slot");
        }

        // Render stock
        const stockElement = document.getElementById("stock");
        stockElement.innerHTML = ""; // Clear any existing content
        stockElement.addEventListener("click", handleStockClick); // Ensure stock is always clickable
        if (stock.length > 0) {
          const cardElement = createCardElement(stock[stock.length - 1], false);
          stockElement.appendChild(cardElement);
        }

        // Render waste - show up to 2 cards
        const wasteElement = document.getElementById("waste");
        if (waste.length > 0) {
          const cardElement = createCardElement(waste[waste.length - 1], true);
          wasteElement.appendChild(cardElement);
          if (!gameWon) {
            setupDraggable(cardElement, "waste", waste.length - 1);
            setupRightClickable(cardElement, "waste", waste.length - 1);
          }
        }

        // Render foundations
        for (let i = 0; i < 4; i++) {
          const foundationElement = document.getElementById(`foundation-${i}`);
          if (foundations[i].length > 0) {
            const cardElement = createCardElement(
              foundations[i][foundations[i].length - 1],
              true
            );
            foundationElement.appendChild(cardElement);
            if (!gameWon) {
              setupDraggable(
                cardElement,
                `foundation-${i}`,
                foundations[i].length - 1
              );
            }
          }
        }

        // Render tableau
        for (let i = 0; i < 7; i++) {
          const tableauElement = document.getElementById(`tableau-${i}`);
          const pile = tableau[i];

          pile.forEach((card, j) => {
            const cardElement = createCardElement(card, card.faceUp);
            tableauElement.appendChild(cardElement);
            cardElement.style.top = `${j * 20}px`;

            if (card.faceUp && !gameWon) {
              setupDraggable(cardElement, `tableau-${i}`, j);
              setupRightClickable(cardElement, `tableau-${i}`, j);
            }
          });
        }

        // Check for win
        checkWin();
      }

      // Create a card element
      function createCardElement(card, faceUp) {
        const cardElement = document.createElement("div");
        cardElement.classList.add("card");

        if (!faceUp) {
          cardElement.classList.add("back");
          return cardElement;
        }

        cardElement.classList.add(
          card.color === "red" ? "card-red" : "card-black"
        );
        cardElement.dataset.suit = card.suit;
        cardElement.dataset.value = card.value;

        // Add card value and suit
        const topValue = document.createElement("div");
        topValue.classList.add("card-value");
        topValue.textContent = `${card.value}`;

        const topSuit = document.createElement("div");
        topSuit.classList.add("card-suit");
        topSuit.textContent = card.suit;

        const center = document.createElement("div");
        center.classList.add("card-center");
        center.textContent = card.suit;

        const bottomValue = document.createElement("div");
        bottomValue.classList.add("card-value");
        bottomValue.style.transform = "rotate(180deg)";
        bottomValue.textContent = `${card.value}`;

        const bottomSuit = document.createElement("div");
        bottomSuit.classList.add("card-suit");
        bottomSuit.style.transform = "rotate(180deg)";
        bottomSuit.textContent = card.suit;

        const top = document.createElement("div");
        top.style.display = "flex";
        top.style.flexDirection = "column";
        top.appendChild(topValue);
        top.appendChild(topSuit);

        const bottom = document.createElement("div");
        bottom.style.display = "flex";
        bottom.style.flexDirection = "column";
        bottom.style.alignSelf = "flex-end";
        bottom.appendChild(bottomSuit);
        bottom.appendChild(bottomValue);

        cardElement.appendChild(top);
        cardElement.appendChild(center);
        cardElement.appendChild(bottom);

        return cardElement;
      }

      // Setup draggable functionality for a card
      function setupDraggable(cardElement, sourceId, index) {
        cardElement.setAttribute("draggable", true);
        cardElement.dataset.sourceId = sourceId;
        cardElement.dataset.index = index;

        cardElement.addEventListener("mousedown", handleDragStart);
        cardElement.addEventListener("touchstart", handleTouchStart, {
          passive: false,
        });
      }

      // Handle touch start
      function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousedown", {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true,
        });
        this.dispatchEvent(mouseEvent);
      }

      // Setup right-click functionality for a card
      function setupRightClickable(cardElement, sourceId, index) {
        cardElement.addEventListener("contextmenu", function (e) {
          e.preventDefault(); // Prevent the default context menu
          handleRightClick(e, sourceId, index);
        });

        // Add double-tap handler for mobile
        cardElement.addEventListener("touchend", function (e) {
          const currentTime = Date.now();
          const tapLength = currentTime - lastTap;
          if (tapLength < 300 && tapLength > 0) {
            e.preventDefault();
            handleRightClick(e, sourceId, index);
          }
          lastTap = currentTime;
        });
      }

      // Get card from source for right-click action
      function getCardFromSource(sourceId, index) {
        if (sourceId === "waste") {
          if (waste.length === 0) return null;
          return waste[waste.length - 1];
        }
        if (sourceId.startsWith("tableau-")) {
          const tableauIndex = Number.parseInt(sourceId.split("-")[1], 10);
          const pile = tableau[tableauIndex];
          if (pile.length === 0 || index !== pile.length - 1) return null;
          const card = pile[pile.length - 1];
          return card.faceUp ? card : null;
        }
        return null;
      }

      // Remove card from source after right-click move
      function removeCardFromSource(sourceId) {
        if (sourceId === "waste") {
          waste.pop();
          return;
        }
        if (sourceId.startsWith("tableau-")) {
          const tableauIndex = Number.parseInt(sourceId.split("-")[1], 10);
          tableau[tableauIndex].pop();
          flipTopCardIfNeeded(tableauIndex);
        }
      }

      // Flip the top card of a tableau pile if it's face-down
      function flipTopCardIfNeeded(tableauIndex) {
        const pile = tableau[tableauIndex];
        if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
          pile[pile.length - 1].faceUp = true;
        }
      }

      // Handle right-click (auto-move to foundation)
      function handleRightClick(e, sourceId, index) {
        const card = getCardFromSource(sourceId, index);
        if (!card) return;

        // Try to move to a foundation
        for (let i = 0; i < 4; i++) {
          if (canMoveToFoundation(card, i)) {
            saveGameState();
            removeCardFromSource(sourceId);
            foundations[i].push(card);
            moves++;
            updateStats();
            updateUndoButton();
            updateScore("moveToFoundation");
            renderGame();
            return;
          }
        }
      }

      // Foundation suits: 0=â™ , 1=â™¥, 2=â™¦, 3=â™£
      const foundationSuits = ["â™ ", "â™¥", "â™¦", "â™£"];

      // Check if a card can be moved to a specific foundation
      function canMoveToFoundation(card, foundationIndex) {
        const foundation = foundations[foundationIndex];
        const requiredSuit = foundationSuits[foundationIndex];

        // Card must match the foundation's suit
        if (card.suit !== requiredSuit) {
          return false;
        }

        if (foundation.length === 0) {
          // Empty foundation can only receive an Ace of the matching suit
          return card.value === "A";
        } else {
          // Check if the card can be placed on the foundation
          const topCard = foundation[foundation.length - 1];
          return (
            values.indexOf(card.value) === values.indexOf(topCard.value) + 1
          );
        }
      }

      // Get dragged cards from source pile
      function getDraggedCardsFromSource(sourceId, index) {
        if (sourceId === "waste") {
          return [waste[index]];
        }
        if (sourceId.startsWith("foundation")) {
          const foundationIndex = Number.parseInt(sourceId.split("-")[1], 10);
          return [foundations[foundationIndex][index]];
        }
        if (sourceId.startsWith("tableau")) {
          const tableauIndex = Number.parseInt(sourceId.split("-")[1], 10);
          const pile = tableau[tableauIndex];
          if (index < pile.length - 1 && canDragSequence(pile, index)) {
            return pile.slice(index);
          }
          return [pile[index]];
        }
        return [];
      }

      // Check if a sequence of cards can be dragged
      function canDragSequence(pile, startIndex) {
        for (let i = startIndex; i < pile.length - 1; i++) {
          const current = pile[i];
          const next = pile[i + 1];
          if (!isSequential(current, next) || !current.faceUp || !next.faceUp) {
            return false;
          }
        }
        return true;
      }

      // Create visual element for dragging
      function createDragVisual(sourceId, index, rect) {
        const cardsCopy = document.createElement("div");
        cardsCopy.style.position = "absolute";
        cardsCopy.style.zIndex = "1000";
        cardsCopy.style.pointerEvents = "none";
        document.body.appendChild(cardsCopy);

        if (sourceId.startsWith("tableau") && draggedCards.length > 1) {
          const tableauIndex = Number.parseInt(sourceId.split("-")[1], 10);
          const tableauCards = document.querySelectorAll(
            `#tableau-${tableauIndex} .card`
          );
          const startIndex = Number.parseInt(index, 10);
          for (let i = startIndex; i < tableauCards.length; i++) {
            const card = tableauCards[i];
            const cardClone = card.cloneNode(true);
            cardClone.style.position = "absolute";
            cardClone.style.left = "0";
            cardClone.style.top = `${(i - startIndex) * 20}px`;
            cardsCopy.appendChild(cardClone);
            card.style.visibility = "hidden";
          }
        } else {
          const cardClone = draggedElement.cloneNode(true);
          cardClone.style.position = "absolute";
          cardClone.style.left = "0";
          cardClone.style.top = "0";
          cardsCopy.appendChild(cardClone);
          draggedElement.style.visibility = "hidden";
        }

        cardsCopy.style.left = `${rect.left}px`;
        cardsCopy.style.top = `${rect.top}px`;
        cardsCopy.classList.add("dragging");
      }

      // Handle drag start
      function handleDragStart(e) {
        if (isDragging) return;

        const sourceId = e.target.closest(".card").dataset.sourceId;
        const index = Number.parseInt(
          e.target.closest(".card").dataset.index,
          10
        );

        draggedCards = getDraggedCardsFromSource(sourceId, index);
        dragSourceElement = document.getElementById(
          sourceId === "waste" ? "waste" : sourceId
        );

        if (draggedCards.length === 0 || !draggedCards[0].faceUp) return;

        isDragging = true;
        draggedElement = e.target.closest(".card");

        const rect = draggedElement.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        initialX = rect.left;
        initialY = rect.top;

        createDragVisual(sourceId, index, rect);

        document.addEventListener("mousemove", handleDragMove);
        document.addEventListener("mouseup", handleDragEnd);

        e.preventDefault();
      }

      // Handle drag move
      function handleDragMove(e) {
        if (!isDragging) return;

        const dragElement = document.querySelector(".dragging");
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        dragElement.style.left = `${initialX + deltaX}px`;
        dragElement.style.top = `${initialY + deltaY}px`;

        e.preventDefault();
      }

      // Find valid drop target from elements under pointer
      function findDropTarget(elementsUnderPointer) {
        for (const element of elementsUnderPointer) {
          if (
            element.id.startsWith("foundation-") ||
            element.id.startsWith("tableau-")
          ) {
            return element;
          }
          if (element.classList.contains("card")) {
            const tableauParent = element.closest(".tableau-pile");
            if (tableauParent) return element;
            const foundationParent = element.closest(
              '.card-slot[id^="foundation-"]'
            );
            if (foundationParent) return element;
          }
        }
        return null;
      }

      // Get target pile ID from target element
      function getTargetPileId(targetElement) {
        if (!targetElement.classList.contains("card")) {
          return targetElement.id;
        }
        const tableauParent = targetElement.closest(".tableau-pile");
        if (tableauParent) return tableauParent.id;
        const foundationParent = targetElement.closest(".card-slot");
        if (foundationParent) return foundationParent.id;
        return targetElement.id;
      }

      // Clean up after drag
      function cleanupDrag() {
        if (draggedElement) {
          draggedElement.style.visibility = "";
          if (
            draggedElement.dataset.sourceId.startsWith("tableau") &&
            draggedCards.length > 1
          ) {
            const tableauIndex = Number.parseInt(
              draggedElement.dataset.sourceId.split("-")[1],
              10
            );
            const tableauCards = document.querySelectorAll(
              `#tableau-${tableauIndex} .card`
            );
            const startIndex = Number.parseInt(
              draggedElement.dataset.index,
              10
            );
            for (let i = startIndex; i < tableauCards.length; i++) {
              tableauCards[i].style.visibility = "";
            }
          }
        }
        draggedCards = [];
        draggedElement = null;
        dragSourceElement = null;
      }

      // Handle drag end
      function handleDragEnd(e) {
        if (!isDragging) return;

        isDragging = false;
        const dragElement = document.querySelector(".dragging");
        const elementsUnderPointer = document.elementsFromPoint(
          e.clientX,
          e.clientY
        );
        const targetElement = findDropTarget(elementsUnderPointer);

        if (targetElement) {
          const targetId = getTargetPileId(targetElement);
          if (
            tryMove(draggedCards, draggedElement.dataset.sourceId, targetId)
          ) {
            moves++;
            updateStats();
          }
        }

        if (dragElement) dragElement.remove();
        cleanupDrag();

        document.removeEventListener("mousemove", handleDragMove);
        document.removeEventListener("mouseup", handleDragEnd);

        renderGame();
        e.preventDefault();
      }

      // Check if card can be placed on tableau pile
      function canPlaceOnTableau(card, tableauPile) {
        if (tableauPile.length === 0) {
          return card.value === "K";
        }
        const topCard = tableauPile[tableauPile.length - 1];
        return (
          topCard.faceUp &&
          card.color !== topCard.color &&
          values.indexOf(card.value) === values.indexOf(topCard.value) - 1
        );
      }

      // Try to move cards between piles
      function tryMove(cards, sourceId, targetId) {
        if (!cards || cards.length === 0) return false;

        // Prevent moving cards from foundation to foundation (score farming)
        if (
          sourceId.startsWith("foundation-") &&
          targetId.startsWith("foundation-")
        ) {
          return false;
        }

        if (targetId.startsWith("foundation-")) {
          if (cards.length !== 1) return false;
          const foundationIndex = Number.parseInt(targetId.split("-")[1], 10);
          return (
            canMoveToFoundation(cards[0], foundationIndex) &&
            performMove(cards, sourceId, targetId)
          );
        }

        if (targetId.startsWith("tableau-")) {
          const tableauIndex = Number.parseInt(targetId.split("-")[1], 10);
          if (canPlaceOnTableau(cards[0], tableau[tableauIndex])) {
            return performMove(cards, sourceId, targetId);
          }
        }

        return false;
      }

      // Perform the move after validation
      function performMove(cards, sourceId, targetId) {
        saveGameState();
        removeFromSource(cards, sourceId);

        if (targetId.startsWith("foundation-")) {
          const foundationIndex = Number.parseInt(targetId.split("-")[1], 10);
          foundations[foundationIndex].push(cards[0]);
          updateScore("moveToFoundation");
        } else if (targetId.startsWith("tableau-")) {
          const tableauIndex = Number.parseInt(targetId.split("-")[1], 10);
          tableau[tableauIndex] = tableau[tableauIndex].concat(cards);
          updateScore("moveToTableau");
        }

        return true;
      }

      // Remove cards from source pile
      function removeFromSource(cards, sourceId) {
        if (sourceId === "waste") {
          waste.pop();
        } else if (sourceId.startsWith("foundation-")) {
          const foundationIndex = Number.parseInt(sourceId.split("-")[1], 10);
          foundations[foundationIndex].pop();
        } else if (sourceId.startsWith("tableau-")) {
          const tableauIndex = Number.parseInt(sourceId.split("-")[1], 10);
          tableau[tableauIndex] = tableau[tableauIndex].slice(0, -cards.length);
          flipTopCardIfNeeded(tableauIndex);
        }
      }

      // Handle click on stock
      function handleStockClick() {
        if (!gameWon) {
          saveGameState();
          if (stock.length === 0) {
            if (waste.length > 0) {
              // Move all waste cards back to stock
              stock = waste.slice().reverse();
              stock.forEach((card) => (card.faceUp = false));
              waste = [];
              moves++;
              updateStats();
              renderGame();
            }
          } else {
            // Move card from stock to waste
            const card = stock.pop();
            card.faceUp = true;
            waste.push(card);
            moves++;
            updateStats();
            renderGame();
          }
        }
      }

      // Update stats display
      function updateStats() {
        document.querySelector(".moves").textContent = moves;
        document.querySelector(".score").textContent = score;
      }

      // Update score based on actions
      function updateScore(action) {
        switch (action) {
          case "moveToFoundation":
            score += 10; // Add points for moving a card to a foundation
            break;
          case "moveToTableau":
            score += 5; // Add points for moving a card to the tableau
            break;
          case "undoMove":
            score -= 5; // Deduct points for undoing a move
            break;
          default:
            break;
        }
        updateStats();
      }

      // Format time as string
      function formatTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
      }

      // Update time display
      function updateTime() {
        time++;
        document.querySelector(".time").textContent = formatTime(time);
      }

      // Check if cards are sequential (for tableau)
      function isSequential(card1, card2) {
        return (
          card1.color !== card2.color &&
          values.indexOf(card1.value) === values.indexOf(card2.value) + 1
        );
      }

      // Check for win
      function checkWin() {
        const totalFoundationCards = foundations.reduce(
          (sum, foundation) => sum + foundation.length,
          0
        );
        if (totalFoundationCards === 52) {
          clearInterval(timer);
          gameWon = true;
          showWinMessage();
        }
      }

      // Show win message with stats
      function showWinMessage() {
        document.getElementById("win-moves").textContent = moves;
        document.getElementById("win-time").textContent = formatTime(time);
        document.getElementById("win-score").textContent = score;
        document.getElementById("win-message").style.display = "flex";
      }

      // Save game state for undo
      function saveGameState() {
        const state = {
          stock: structuredClone(stock),
          waste: structuredClone(waste),
          foundations: structuredClone(foundations),
          tableau: structuredClone(tableau),
          moves: moves,
          score: score,
        };
        gameHistory.push(state);
        // Limit undo history to 5 moves
        if (gameHistory.length > 5) {
          gameHistory.shift();
        }
        updateUndoButton();
      }

      // Undo last move
      function undoMove() {
        if (gameHistory.length === 0) return;

        const previousState = gameHistory.pop();
        stock = previousState.stock;
        waste = previousState.waste;
        foundations = previousState.foundations;
        tableau = previousState.tableau;
        moves = previousState.moves;
        score = previousState.score;

        updateStats();
        updateUndoButton();
        renderGame();
      }

      // Update undo button state
      function updateUndoButton() {
        const undoButton = document.getElementById("undo");
        undoButton.disabled = gameHistory.length === 0;
      }

      // Event listeners
      document.getElementById("new-game").addEventListener("click", initGame);
      document.getElementById("undo").addEventListener("click", undoMove);
      document.getElementById("play-again").addEventListener("click", initGame);

      // Initialize the game on load
      window.addEventListener("load", initGame);

      // Modify existing event listeners to handle touch events
      document.addEventListener(
        "touchmove",
        (e) => {
          if (isDragging) {
            e.preventDefault();
            const touch = e.touches[0];
            handleDragMove({
              clientX: touch.clientX,
              clientY: touch.clientY,
              preventDefault: () => e.preventDefault(),
            });
          }
        },
        { passive: false }
      );

      document.addEventListener(
        "touchend",
        (e) => {
          if (isDragging) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            handleDragEnd({
              clientX: touch.clientX,
              clientY: touch.clientY,
              preventDefault: () => e.preventDefault(),
            });
          }
        },
        { passive: false }
      );

      // Add double-tap handling for right-click alternative
      let lastTap = 0;
    </script>
  </body>
</html>
